//! Provides a powerful macro, `define_directives!`, for creating and managing
//! language-specific coding guidance. This module is the core of the AI's ability
//! to adapt its coding style dynamically.

/// Defines the `LanguageGuide` enum and its associated functions for loading
/// coding style directives based on programming languages.
///
/// This macro simplifies the process of adding new languages and their corresponding
/// guidance content. It uses a declarative syntax to map language names and aliases
/// to content sourced from inline strings, single files, or a combination of multiple files.
///
/// # Syntax
///
/// The macro expects one or more language definitions, each following the pattern:
///
/// ```rust,ignore
/// LanguageName("alias1", "alias2") => content_loader!("path/or/string")
/// ```
///
/// - `LanguageName`: The identifier for the language in the generated `LanguageGuide` enum (e.g., `Python`).
/// - `("alias1", ...)`: A list of lowercase string aliases used for matching (e.g., `"py"`).
/// - `content_loader!`: One of three supported loaders:
///   - `content!("...")`: For short, inline string literals.
///   - `file!("filename.md")`: To include the content of a single file from the `assets/meta-prompt/` directory.
///   - `files!(["file1.md", "file2.py"])`: To concatenate the contents of multiple files.
///
/// # Example Usage
///
/// ```rust,ignore
/// # use schemars::JsonSchema; // Add dependencies for the example to be valid
/// # use serde::{Serialize, Deserialize};
/// # use mcp_rs::define_directives;
/// define_directives! {
///     // 1. For simple, inline string content
///     Go("golang") => content!("Go guidance placeholder."),
///
///     // 2. To load a single, specific directive file
///     Rust("rs") => file!("d-rust.md"), // Assumes a 'd-rust.md' file exists
///
///     // 3. To combine multiple files into one master directive
///     Python("py") => files!(["d-python.md", "d-python.py"]),
///
///     // You can mix and match as needed
///     Web("js", "ts", "svelte") => content!("Web technologies guidance placeholder."),
///     C("cpp", "c++") => content!("C-based languages guidance placeholder.")
/// }
/// ```
#[macro_export]
macro_rules! define_directives {
    (
        $($lang:ident ($($alias:literal),*) => $content_type:ident ! ( $($content:tt)* ) ),+
        $(,)?
    ) => {
        // --- LanguageGuide Enum ---
        /// An enumeration of all supported programming languages for which
        /// coding directives are available.
        #[derive(Debug, Serialize, Deserialize, JsonSchema)]
        #[serde(rename_all = "camelCase")]
        pub enum LanguageGuide {
            $(
                #[doc = concat!("Represents the ", stringify!($lang), " language and its specific directives.")]
                $lang
            ),+
        }

        impl LanguageGuide {
            /// Parses a string slice to find a matching `LanguageGuide` variant.
            /// The comparison is case-insensitive for the primary language name and
            /// case-sensitive for its aliases.
            pub fn from_string(s: &str) -> Option<Self> {
                let s_lower = s.to_lowercase();
                $(
                    if s_lower == stringify!($lang).to_lowercase() $( || s_lower.as_str() == $alias )* {
                        return Some(Self::$lang);
                    }
                )+
                None
            }
        }

        /// Retrieves the consolidated guidance content for a given `LanguageGuide` variant.
        ///
        /// This function is generated by the macro and contains the logic to load
        /// content from the source specified in the macro definition (inline, file, or files).
        pub fn get_guidance(lang: LanguageGuide) -> String {
            match lang {
                $(
                    LanguageGuide::$lang => {
                        // The macro calls a helper rule to process the content.
                        define_directives!(@process_content $content_type ! ( $($content)* ))
                    }
                )+
            }
        }
    };

    // --- Helper rule for processing 'content!("...")' ---
    // Handles simple inline strings.
    (@process_content content ! ($str:literal)) => {
        $str.to_string()
    };

    // --- Helper rule for processing 'file!("...")' ---
    // Handles including a single file's content.
    (@process_content file ! ($path:literal)) => {
        include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/../../assets/meta-prompt/", $path)).to_string()
    };

    // --- Helper rule for processing 'files!(["...", "..."])' ---
    // Handles combining multiple files into a single string.
    (@process_content files ! ([$($path:literal),+])) => {
        {
            let mut combined = String::new();
            $(
                let content = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/../../assets/meta-prompt/", $path));
                if !combined.is_empty() {
                    combined.push_str("\n\n---\n\n");
                }
                combined.push_str(content);
            )+
            combined
        }
    };
}
